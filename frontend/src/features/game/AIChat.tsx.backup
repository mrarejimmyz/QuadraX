'use client'

import React, { useState, useRef, useEffect } from 'react'
import { QuadraXAgent, QuadraXAgentFactory, PlayerProfile, PYUSDStakeContext as AgentPYUSDStakeContext, GamePosition as AgentGamePosition } from '../../lib/agents/quadraXAgent'

interface Message {
  id: number
  sender: 'ai' | 'user' | 'agent'
  text: string
  timestamp: Date
  agentName?: string
  confidence?: number
  reasoning?: string
}

interface GamePosition {
  board: number[]
  phase: 'placement' | 'movement'
  piecesPlaced: { player1: number, player2: number }
  currentPlayer: number
}

interface PYUSDStakeContext {
  playerBalance: number
  opponentBalance: number
  minStake: number
  maxStake: number
  standardStake: number
  gameId?: string
}

interface AIChatProps {
  aiName?: string
  enabled?: boolean
  gameId?: string
  gamePosition?: GamePosition
  stakingContext?: PYUSDStakeContext
}

export default function AIChat({ 
  aiName = 'QuadraX AI', 
  enabled = true, 
  gameId = 'demo-game',
  gamePosition,
  stakingContext
}: AIChatProps) {
  const [agents, setAgents] = useState<QuadraXAgent[]>([])
  const [messages, setMessages] = useState<Message[]>([])
  const [input, setInput] = useState('')
  const [isProcessing, setIsProcessing] = useState(false)
  const [activeMode, setActiveMode] = useState<'chat' | 'analysis' | 'negotiation' | 'strategy'>('chat')
  const messagesEndRef = useRef<HTMLDivElement>(null)

  // Initialize QuadraX agents with proper configurations
  useEffect(() => {
    const initializeAgents = async () => {
      try {
        // Create diverse QuadraX agents using factory methods
        const agentList: QuadraXAgent[] = [
          QuadraXAgentFactory.createStrategicAnalyst('AlphaStrategist', '0.0.3001', 'strategic-key'),
          QuadraXAgentFactory.createDefensiveExpert('BetaDefender', '0.0.3002', 'defensive-key'),
          QuadraXAgentFactory.createAggressiveTrader('GammaAggressor', '0.0.3003', 'aggressive-key'),
          QuadraXAgentFactory.createAdaptivePlayer('DeltaEvolver', '0.0.3004', 'adaptive-key')
        ]

        // Verify Ollama connections
        const connectedAgents: QuadraXAgent[] = []
        for (const agent of agentList) {
          try {
            const connected = await agent.checkOllamaConnection()
            if (connected) {
              connectedAgents.push(agent)
            }
          } catch (error) {
            console.warn(`Agent ${agent.name} connection failed:`, error)
          }
        }
        
        setAgents(connectedAgents)
        
        const welcomeMessage: Message = {
          id: Date.now(),
          sender: 'ai',
          text: `ðŸš€ QuadraX AI System Online!

ðŸ¤– Agents Initialized: ${connectedAgents.length}/4

${connectedAgents.map(agent => 
  `â€¢ ${agent.name}: ${agent.personality.riskProfile} specialist
  Expertise: ${agent.personality.expertise.slice(0, 2).join(', ')}`
).join('\n')}

ï¿½ PYUSD Staking: 10 PYUSD standard (negotiable 1-10)
ðŸŽ® Game Mode: 4x4 QuadraX with placement/movement phases
ðŸ§  AI Model: Llama 3.2 (2GB optimized)

Type 'help' for available commands!`,
          timestamp: new Date()
        }
        setMessages([welcomeMessage])
        
      } catch (error) {
        console.error('Failed to initialize QuadraX agents:', error)
        const errorMessage: Message = {
          id: Date.now(),
          sender: 'ai',
          text: 'âš ï¸ QuadraX AI agents are currently offline. Please ensure Ollama is running with llama3.2:latest model.',
          timestamp: new Date()
        }
        setMessages([errorMessage])
      }
    }
    
    initializeAgents()
  }, [])

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })
  }

  useEffect(() => {
    scrollToBottom()
  }, [messages])

  // Handle different AI commands
  const handleAICommand = async (command: string) => {
    setIsProcessing(true)
    const userMessage: Message = {
      id: Date.now(),
      sender: 'user',
      text: command,
      timestamp: new Date()
    }
    setMessages(prev => [...prev, userMessage])

    // Mock data for agent interactions
    const mockOpponent: PlayerProfile = {
      address: '0x123456789abcdef',
      gamesPlayed: 25,
      winRate: 0.72,
      averageStake: 8.5,
      preferredStrategy: 'adaptive',
      stakingPattern: 'moderate',
      gameHistory: []
    }
    
    const mockPyusdContext = {
      minStake: 1,
      platformFee: 0.25,
      gasEstimate: 0.001,
      playerBalance: 100,
      opponentBalance: 80,
      marketConditions: 'stable' as const
    }

    try {
      if (command.toLowerCase().includes('help')) {
        // Use real AI agent for help if available, otherwise static response
        if (agents.length > 0) {
          const agent = agents[0]
          try {
            // Get a real AI-powered help response through analysis
            const helpAnalysis = await agent.analyzeQuadraXPosition(
              {
                board: Array(16).fill(0),
                phase: 'placement',
                player1Pieces: 0,
                player2Pieces: 0,
                currentPlayer: 1,
                possibleMoves: Array.from({length: 16}, (_, i) => i),
                threatLevel: 'low'
              },
              mockOpponent,
              mockPyusdContext
            )
            
            const aiHelpMessage: Message = {
              id: Date.now() + 1,
              sender: 'agent',
              text: `ðŸ¤– ${agent.name} (AI-powered help):

ï¿½ **I can help you with**:
â€¢ **"analyze"** - Real AI analysis of game positions
â€¢ **"how much to stake"** - PYUSD calculations with Kelly Criterion  
â€¢ **"negotiate"** - Multi-agent stake negotiations
â€¢ **"agents"** - Meet your AI team
â€¢ **"move"** - Strategic move recommendations

ðŸ§  **Powered by Llama 3.2**: Ask me anything naturally!
Examples: "What's a good stake amount?" "How does the game work?" "Should I be aggressive?"

ðŸŽ® **Current Status**: ${agents.length} AI agents ready, Ollama ${helpAnalysis ? 'âœ… Online' : 'âŒ Offline'}`,
              timestamp: new Date(),
              agentName: agent.name
            }
            setMessages(prev => [...prev, aiHelpMessage])
          } catch (error) {
            // Fallback to static help
            console.warn('AI help generation failed, using static help')
            const staticHelpMessage: Message = {
              id: Date.now() + 1,
              sender: 'ai',
              text: `ðŸ¤– QuadraX Commands (Ollama offline):
ðŸ’° "stake" - PYUSD calculations | ðŸŽ® "analyze" - Position analysis
ðŸ¤– "agents" - AI team | ðŸ†˜ "help" - This menu
ðŸš€ Start Ollama for AI-powered responses!`,
              timestamp: new Date()
            }
            setMessages(prev => [...prev, staticHelpMessage])
          }
        } else {
          const staticHelpMessage: Message = {
            id: Date.now() + 1,
            sender: 'ai',
            text: `ðŸ¤– QuadraX Commands (No agents loaded):
ðŸ’° "stake" - PYUSD info | ðŸŽ® "analyze" - Game analysis  
ðŸ¤– "agents" - Agent status | ðŸš€ Restart to load AI agents`,
            timestamp: new Date()
          }
          setMessages(prev => [...prev, staticHelpMessage])
        }
      }
      else if (command.toLowerCase().includes('agents')) {
        const agentMessage: Message = {
          id: Date.now() + 1,
          sender: 'ai',
          text: `ðŸ¤– Active QuadraX Agents: ${agents.length}

${agents.map((agent, index) => 
  `${index + 1}. ${agent.name}
     â€¢ Profile: ${agent.personality.riskProfile}
     â€¢ Style: ${agent.personality.negotiationStyle}
     â€¢ Traits: ${agent.personality.traits.join(', ')}
     â€¢ Account: ${agent.hederaAccountId}`
).join('\n\n')}`,
          timestamp: new Date()
        }
        setMessages(prev => [...prev, agentMessage])
      }
      else if (command.toLowerCase().includes('analyze') && gamePosition) {
        if (agents.length > 0) {
          const agent = agents[0] // Use first available agent
          
          // Convert GamePosition to AgentGamePosition format
          const agentGamePosition: AgentGamePosition = {
            board: gamePosition.board,
            phase: 'placement', // Default to placement phase
            player1Pieces: gamePosition.board.filter(cell => cell === 1).length,
            player2Pieces: gamePosition.board.filter(cell => cell === 2).length,
            currentPlayer: (gamePosition.currentPlayer === 1 ? 1 : 2) as 1 | 2,
            possibleMoves: gamePosition.board.map((cell, index) => cell === 0 ? index : -1).filter(pos => pos !== -1),
            threatLevel: 'medium'
          }
          
          const analysis = await agent.analyzeQuadraXPosition(
            agentGamePosition,
            mockOpponent,
            mockPyusdContext
          )
          
          const analysisMessage: Message = {
            id: Date.now() + 1,
            sender: 'agent',
            text: `ðŸ§  ${agent.name}'s Analysis:

ðŸ“Š Win Probability: ${analysis.winProbability}%
ðŸŽ® Phase Strategy: ${analysis.phaseStrategy}
âš ï¸ Threat Level: ${analysis.threatAssessment}

ðŸŽ¯ Win Condition Analysis:
â€¢ Horizontal: ${analysis.winConditionAnalysis.horizontal}%
â€¢ Vertical: ${analysis.winConditionAnalysis.vertical}%  
â€¢ Diagonal: ${analysis.winConditionAnalysis.diagonal}%
â€¢ Square: ${analysis.winConditionAnalysis.square}%

ðŸ’­ Strategic Reasoning:
${analysis.reasoning.substring(0, 250)}...`,
            timestamp: new Date(),
            agentName: agent.name,
            confidence: analysis.confidence
          }
          setMessages(prev => [...prev, analysisMessage])
        }
      }
      // Enhanced staking queries - handle natural language
      else if (command.toLowerCase().includes('stake') || 
               command.toLowerCase().includes('how much') || 
               command.toLowerCase().includes('cost') ||
               command.toLowerCase().includes('price') ||
               command.toLowerCase().includes('pyusd') ||
               command.toLowerCase().includes('money')) {
        
        if (agents.length > 0) {
          const agent = agents[Math.floor(Math.random() * agents.length)] // Random agent
          
          // Use real Ollama AI for natural language staking queries
          if (command.toLowerCase().includes('how much') || 
              command.toLowerCase().includes('cost') || 
              command.toLowerCase().includes('price')) {
            
            try {
              // Use real Ollama AI through the agent's calculateQuadraXStake method
              // This will give us a real AI-powered response with reasoning
              const stakeCalc = await agent.calculateQuadraXStake(
                0.65, // Estimated win probability for general query
                mockOpponent,
                mockPyusdContext,
                { 
                  isRankedMatch: false,
                  tournamentMultiplier: 1,
                  timeRemaining: 300
                }
              )
              
              const realAIMessage: Message = {
                id: Date.now() + 1,
                sender: 'agent',
                text: `ðŸ¤– ${agent.name} (${agent.personality.riskProfile} specialist) responds to "${command}":

ðŸ’° **My Recommendation**: ${stakeCalc.recommendedStake} PYUSD
ðŸ“Š **Safe Range**: ${stakeCalc.minStake} - ${stakeCalc.maxStake} PYUSD

ðŸ§  **AI Analysis** (powered by Llama 3.2):
${stakeCalc.reasoning}

ðŸŽ¯ **Risk Assessment**:
${stakeCalc.riskAssessment}

ðŸ’¡ **Kelly Calculation**:
${stakeCalc.kellyCalculation}`,
                timestamp: new Date(),
                agentName: agent.name
              }
              setMessages(prev => [...prev, realAIMessage])
              return
            } catch (error) {
              console.error('Real AI analysis failed:', error)
              // Fallback to basic info if Ollama is unavailable
              const fallbackMessage: Message = {
                id: Date.now() + 1,
                sender: 'agent',
                text: `ðŸ’° ${agent.name} (Ollama offline):
ðŸŽ¯ Standard: 10 PYUSD | Range: 1-50 PYUSD
âš–ï¸ Winner takes ~95% after 0.25% fee
ðŸš€ Start Ollama server for real AI analysis!`,
                timestamp: new Date(),
                agentName: agent.name
              }
              setMessages(prev => [...prev, fallbackMessage])
              return
            }
          }
          
          // Calculate detailed stake for specific requests
          const stakeCalc = await agent.calculateQuadraXStake(
            0.65, // Mock win probability
            {
              address: '0x123456789abcdef',
              gamesPlayed: 18,
              winRate: 0.72,
              averageStake: 8.5,
              preferredStrategy: 'adaptive',
              stakingPattern: 'moderate',
              gameHistory: []
            },
            mockPyusdContext,
            { 
              isRankedMatch: false,
              tournamentMultiplier: 1,
              timeRemaining: 300
            }
          )
          
          const stakeMessage: Message = {
            id: Date.now() + 1,
            sender: 'agent',
            text: `ðŸ’° ${agent.name}'s Detailed Stake Calculation:

ðŸŽ¯ **Optimal for You**: ${stakeCalc.recommendedStake} PYUSD
ðŸ“Š **Safe Range**: ${stakeCalc.minStake} - ${stakeCalc.maxStake} PYUSD
ðŸ§® **Method**: Kelly Criterion + ${agent.personality.riskProfile} adjustment

ï¿½ **Market Analysis**:
${stakeCalc.reasoning.substring(0, 200)}...

ðŸ’¡ **Next Steps**: 
â€¢ Type 'negotiate' to start AI-vs-AI stake negotiation
â€¢ Type 'risk' for detailed risk assessment`,
            timestamp: new Date(),
            agentName: agent.name
          }
          setMessages(prev => [...prev, stakeMessage])
        } else {
          // No agents available - provide basic info
          const basicStakeMessage: Message = {
            id: Date.now() + 1,
            sender: 'ai',
            text: `ðŸ’° QuadraX Staking Information:

ðŸŽ¯ **Standard Amount**: 10 PYUSD
ðŸ“Š **Range**: 1-50 PYUSD (flexible)
âš–ï¸ **Winner Takes**: ~95% (after 0.25% platform fee)

ðŸ’¡ **Example**:
â€¢ You stake: 10 PYUSD
â€¢ Opponent stakes: 10 PYUSD  
â€¢ Total pot: 20 PYUSD
â€¢ Winner gets: ~19.95 PYUSD
â€¢ Platform fee: ~0.05 PYUSD

ðŸš€ Start Ollama with 'ollama serve' for AI-powered stake optimization!`,
            timestamp: new Date()
          }
          setMessages(prev => [...prev, basicStakeMessage])
        }
      }
      else if (command.toLowerCase().includes('negotiate') && stakingContext) {
        if (agents.length >= 2) {
          const agent1 = agents[0]
          const agent2 = agents[1]
          
          // Simulate negotiation between two agents
          const negotiation1 = await agent1.negotiateQuadraXStake(
            10, 7, 
            mockOpponent,
            mockPyusdContext,
            1,
            []
          )
          
          const negotiation2 = await agent2.negotiateQuadraXStake(
            7, 10,
            mockOpponent,
            mockPyusdContext, 
            1,
            []
          )
          
          const negotiationMessage: Message = {
            id: Date.now() + 1,
            sender: 'agent',
            text: `ðŸ¤ Live Agent Negotiation:

ðŸ¤– ${agent1.name}: ${negotiation1.decision.toUpperCase()}
   ðŸ’° Counter: ${negotiation1.counterOffer || 'None'} PYUSD
   ðŸ’­ "${negotiation1.message?.substring(0, 100)}..."

ðŸ¤– ${agent2.name}: ${negotiation2.decision.toUpperCase()}  
   ðŸ’° Counter: ${negotiation2.counterOffer || 'None'} PYUSD
   ðŸ’­ "${negotiation2.message?.substring(0, 100)}..."`,
            timestamp: new Date(),
            agentName: 'Negotiation System'
          }
          setMessages(prev => [...prev, negotiationMessage])
        }
      }
      else if (command.toLowerCase().includes('move') && gamePosition) {
        if (agents.length > 0) {
          const agent = agents[Math.floor(Math.random() * agents.length)]
          const availableMoves = gamePosition.board
            .map((cell, index) => cell === 0 ? index : null)
            .filter(pos => pos !== null) as number[]
          
          // Convert to agent game position
          const agentGamePos: AgentGamePosition = {
            board: gamePosition.board,
            phase: 'placement',
            player1Pieces: gamePosition.board.filter(cell => cell === 1).length,
            player2Pieces: gamePosition.board.filter(cell => cell === 2).length,
            currentPlayer: (gamePosition.currentPlayer === 1 ? 1 : 2) as 1 | 2,
            possibleMoves: availableMoves,
            threatLevel: 'medium'
          }
          
          const moveRecommendation = await agent.selectQuadraXMove(
            agentGamePos,
            mockOpponent,
            300 // 5 minutes
          )
          
          const moveMessage: Message = {
            id: Date.now() + 1,
            sender: 'agent',
            text: `ðŸŽ¯ ${agent.name}'s Move Recommendation:

ðŸŽ® Recommended Position: ${moveRecommendation.move}
ðŸ“Š Strategy: ${moveRecommendation.phaseStrategy}
ðŸ”„ Backup Options: ${moveRecommendation.backupMoves?.join(', ') || 'None'}

ðŸ’­ Tactical Reasoning:
${moveRecommendation.reasoning.substring(0, 200)}...`,
            timestamp: new Date(),
            agentName: agent.name,
            confidence: moveRecommendation.confidence
          }
          setMessages(prev => [...prev, moveMessage])
        }
      }
      else if (command.toLowerCase().includes('status')) {
        const statusMessage: Message = {
          id: Date.now() + 1,
          sender: 'ai',
          text: `ðŸ“Š QuadraX AI System Status:

ðŸ¤– Active Agents: ${agents.length}/4
ðŸ”— Ollama Connection: ${agents.length > 0 ? 'âœ… Online' : 'âŒ Offline'}
ðŸ§  AI Model: llama3.2:latest
ðŸŽ® Game Mode: ${gamePosition?.phase || 'Not Started'}
ðŸ’° PYUSD Context: ${stakingContext ? 'âœ… Available' : 'âŒ Not Set'}
ðŸ”„ Processing: ${isProcessing ? 'âš™ï¸ Active' : 'âœ… Ready'}

ðŸŽ¯ Ready for: Strategic analysis, PYUSD negotiations, move recommendations`,
          timestamp: new Date()
        }
        setMessages(prev => [...prev, statusMessage])
      }
      else {
        // Handle greetings and general conversation properly
        const lowerCommand = command.toLowerCase()
        
        if (lowerCommand.includes('hello') || lowerCommand.includes('hi') || lowerCommand.includes('hey')) {
          const agent = agents.length > 0 ? agents[Math.floor(Math.random() * agents.length)] : null
          
          if (agent) {
            const greetingMessage: Message = {
              id: Date.now() + 1,
              sender: 'agent',
              text: `ðŸ‘‹ Hello! I'm ${agent.name}, your ${agent.personality.riskProfile} QuadraX AI specialist.

ðŸŽ® **Ready to help with**:
â€¢ Strategic analysis & game evaluation
â€¢ PYUSD staking optimization (Kelly Criterion)
â€¢ Risk assessment & opponent psychology
â€¢ 4x4 QuadraX tactics (placement + movement)

ðŸ’° **Quick Info**: Standard stake is 10 PYUSD (negotiable 1-10 range)
ðŸ§  **Powered by**: Llama 3.2 8B via Ollama

What would you like to know about QuadraX strategy?`,
              timestamp: new Date(),
              agentName: agent.name
            }
            setMessages(prev => [...prev, greetingMessage])
          } else {
            const basicGreetingMessage: Message = {
              id: Date.now() + 1,
              sender: 'ai',
              text: `ðŸ‘‹ Hello! Welcome to QuadraX AI system.
ðŸ”„ Loading AI agents... Please wait a moment.
ðŸš€ Ensure Ollama is running: \`ollama serve\``,
              timestamp: new Date()
            }
            setMessages(prev => [...prev, basicGreetingMessage])
          }
        }
        // Handle questions about the game or general queries
        else if (lowerCommand.includes('what') || lowerCommand.includes('how') || lowerCommand.includes('explain') || lowerCommand.includes('tell me')) {
          const agent = agents.length > 0 ? agents[0] : null
          
          if (agent) {
            const explainMessage: Message = {
              id: Date.now() + 1,
              sender: 'agent',
              text: `ðŸŽ® ${agent.name} explains QuadraX:

**ðŸ Game Objective**: Get 4 pieces in a row, column, diagonal, or 2x2 square
**ðŸ“ Board**: 4x4 grid (16 positions) - bigger than regular TicTacToe!
**ðŸŽ¯ Pieces**: Each player gets exactly 4 pieces
**âš¡ Phases**: 1) Placement (put pieces anywhere) â†’ 2) Movement (slide pieces around)
**ðŸ† Winner**: Always someone wins (no ties possible!)

**ðŸ’° PYUSD Staking**:
â€¢ Both players bet PYUSD cryptocurrency
â€¢ Winner takes ~95% (after 0.25% platform fee)
â€¢ Standard: 10 PYUSD, Range: 1-50+ PYUSD

**ðŸ¤– AI Features**:
â€¢ Real-time position analysis
â€¢ Kelly Criterion stake optimization  
â€¢ Multi-agent negotiations
â€¢ Opponent psychology profiling

Ask me: "How much should I stake?" or "Analyze this position!"`,
              timestamp: new Date(),
              agentName: agent.name
            }
            setMessages(prev => [...prev, explainMessage])
          }
        }
        // Fallback for unrecognized input
        else if (agents.length > 0) {
          console.warn('AI conversation failed, using fallback')
          // Fallback to helpful static response
          const fallbackMessage: Message = {
            id: Date.now() + 1,
            sender: 'ai',
            text: `ðŸ¤” I'm not sure about "${command.substring(0, 30)}${command.length > 30 ? '...' : ''}"

ðŸ’¡ Try asking:
â€¢ "How much should I stake?" - PYUSD guidance
â€¢ "Analyze this position" - Game analysis
â€¢ "What do you think?" - General AI advice
â€¢ "Help" - Full command list

ðŸš€ Real AI responses available when Ollama is running!`,
            timestamp: new Date()
          }
          setMessages(prev => [...prev, fallbackMessage])
        } else {
          const noAgentsMessage: Message = {
            id: Date.now() + 1,
            sender: 'ai',
            text: `ðŸ¤– No AI agents loaded yet.

ðŸ”„ Please wait for agents to initialize or refresh the page.
ðŸš€ Ensure Ollama is running: \`ollama serve\``,
            timestamp: new Date()
          }
          setMessages(prev => [...prev, noAgentsMessage])
        }
      }
    } catch (error) {
      console.error('AI command error:', error)
      const errorMessage: Message = {
        id: Date.now() + 1,
        sender: 'ai',
        text: 'âš ï¸ AI processing error. Please try again or check Ollama connection.',
        timestamp: new Date()
      }
      setMessages(prev => [...prev, errorMessage])
    } finally {
      setIsProcessing(false)
    }
  }

  const sendMessage = async () => {
    if (!input.trim() || isProcessing) return
    
    const userInput = input.trim()
    setInput('')
    
    await handleAICommand(userInput)
  }

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      sendMessage()
    }
  }

  if (!enabled) {
    return (
      <div className="bg-gray-900/50 backdrop-blur-md rounded-xl border border-gray-700/50 p-4 text-center">
        <p className="text-gray-400">AI Chat disabled</p>
      </div>
    )
  }

  return (
    <div className="bg-gray-900/50 backdrop-blur-md rounded-xl border border-gray-700/50 flex flex-col h-[500px]">
      {/* Header */}
      <div className="p-4 border-b border-gray-700/50 flex items-center justify-between">
        <div className="flex items-center gap-3">
          <div className="w-3 h-3 bg-green-400 rounded-full animate-pulse"></div>
          <h3 className="text-lg font-semibold text-white">{aiName}</h3>
        </div>
        <div className="text-xs text-gray-400">
          {agents.length} agents | {messages.length} messages
        </div>
      </div>

      {/* Mode Selector */}
      <div className="p-2 border-b border-gray-700/50 flex gap-1">
        {(['chat', 'analysis', 'negotiation', 'strategy'] as const).map(mode => (
          <button
            key={mode}
            onClick={() => setActiveMode(mode)}
            className={`px-3 py-1 text-xs rounded-lg transition-all ${
              activeMode === mode 
                ? 'bg-blue-500 text-white' 
                : 'text-gray-400 hover:text-white hover:bg-gray-700/50'
            }`}
          >
            {mode.charAt(0).toUpperCase() + mode.slice(1)}
          </button>
        ))}
      </div>

      {/* Messages */}
      <div className="flex-1 p-4 overflow-y-auto space-y-3">
        {messages.map(message => (
          <div key={message.id} className={`flex ${message.sender === 'user' ? 'justify-end' : 'justify-start'}`}>
            <div className={`max-w-[80%] p-3 rounded-lg ${
              message.sender === 'user' 
                ? 'bg-blue-500 text-white' 
                : message.sender === 'agent'
                ? 'bg-purple-600/20 border border-purple-400/30 text-purple-100'
                : 'bg-gray-700/50 text-gray-100'
            }`}>
              {message.agentName && (
                <div className="text-xs font-semibold text-purple-300 mb-1">
                  ðŸ¤– {message.agentName}
                  {message.confidence && (
                    <span className="ml-2 text-yellow-300">
                      {Math.round(message.confidence * 100)}% confidence
                    </span>
                  )}
                </div>
              )}
              <div className="whitespace-pre-line text-sm">{message.text}</div>
              <div className="text-xs opacity-70 mt-1">
                {message.timestamp.toLocaleTimeString()}
              </div>
            </div>
          </div>
        ))}
        {isProcessing && (
          <div className="flex justify-start">
            <div className="bg-gray-700/50 text-gray-100 p-3 rounded-lg">
              <div className="flex items-center gap-2">
                <div className="w-2 h-2 bg-blue-400 rounded-full animate-bounce"></div>
                <div className="w-2 h-2 bg-blue-400 rounded-full animate-bounce" style={{ animationDelay: '0.1s' }}></div>
                <div className="w-2 h-2 bg-blue-400 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}></div>
                <span className="text-sm text-gray-300 ml-2">AI processing...</span>
              </div>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      {/* Input */}
      <div className="p-4 border-t border-gray-700/50">
        <div className="flex gap-2">
          <input
            type="text"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyPress={handleKeyPress}
            placeholder="Ask AI about strategy, stakes, or moves..."
            disabled={isProcessing || agents.length === 0}
            className="flex-1 bg-gray-800 border border-gray-600 rounded-lg px-3 py-2 text-white placeholder-gray-400 focus:outline-none focus:border-blue-400 disabled:opacity-50"
          />
          <button
            onClick={sendMessage}
            disabled={!input.trim() || isProcessing || agents.length === 0}
            className="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
          >
            Send
          </button>
        </div>
        
        {/* Quick Actions */}
        <div className="flex gap-2 mt-2">
          {['analyze', 'stake', 'move', 'help'].map(action => (
            <button
              key={action}
              onClick={() => handleAICommand(action)}
              disabled={isProcessing || agents.length === 0}
              className="px-2 py-1 text-xs bg-gray-700 text-gray-300 rounded hover:bg-gray-600 disabled:opacity-50"
            >
              {action}
            </button>
          ))}
        </div>
      </div>
    </div>
  )
}
