// Enhanced ASI Alliance Route - Using Modular Architecture
// Complete 4-agent system with referee validation and proper QuadraX rules

import { NextRequest, NextResponse } from 'next/server'

// Import modular ASI Alliance system
import { ASIAllianceFactory } from '@/lib/agents/asi-alliance'
import { QuadraXReferee } from '@/lib/referee/quadraXReferee'
import { scoreMove } from '@/lib/utils/quadraX/moveScoring'
import { checkWin } from '@/lib/utils/quadraX/gameLogic'
import type { GamePosition, AgentDecision, OpponentProfile } from '@/lib/agents/asi-alliance/types'

interface APIGameState {
  board: number[]
  phase: 'placement' | 'movement'
  currentPlayer: number
  placedPieces?: { [player: number]: number }
}

// Extended AgentDecision with score property
interface ExtendedAgentDecision extends AgentDecision {
  score?: number
}

/**
 * Get possible moves for current game state
 */
function getPossibleMoves(board: number[], phase: 'placement' | 'movement', currentPlayer: number): (number | { from: number; to: number })[] {
  if (phase === 'placement') {
    return board.map((cell, index) => cell === 0 ? index : null).filter(pos => pos !== null) as number[]
  } else {
    const playerPieces = board.map((cell, index) => cell === currentPlayer ? index : -1).filter(pos => pos !== -1)
    const emptySpaces = board.map((cell, index) => cell === 0 ? index : -1).filter(pos => pos !== -1)
    
    const moves: { from: number, to: number }[] = []
    for (const piece of playerPieces) {
      for (const empty of emptySpaces) {
        // QuadraX Rule: Pieces can move to ANY empty position on the board
        moves.push({ from: piece, to: empty })
      }
    }
    return moves
  }
}

/**
 * Check if two positions are adjacent (including diagonally)
 */
function isAdjacent(pos1: number, pos2: number): boolean {
  const row1 = Math.floor(pos1 / 4), col1 = pos1 % 4
  const row2 = Math.floor(pos2 / 4), col2 = pos2 % 4
  
  return Math.abs(row1 - row2) <= 1 && Math.abs(col1 - col2) <= 1 && pos1 !== pos2
}

export async function POST(request: NextRequest) {
  try {
    console.log('üß† Enhanced ASI Alliance API - Modular System Activated')
    
    const body = await request.json()
    console.log('üì• Request received:', { 
      board: body.board?.slice(0, 5) + '...', 
      phase: body.phase, 
      currentPlayer: body.currentPlayer 
    })
    
    // CRITICAL DEBUG: Check if movement requests reach this point
    if (body.phase === 'movement') {
      console.log('üö® MOVEMENT PHASE REQUEST DETECTED!')
      console.log('üîç Movement Debug - Full request body:', JSON.stringify(body, null, 2))
    }
    
    // Parse incoming request with multiple format support
    const gameState: APIGameState = {
      board: body.board || body.gamePosition?.board || body.boardState?.board,
      phase: body.phase || body.gamePosition?.phase || body.boardState?.phase || 'placement',
      currentPlayer: body.currentPlayer || body.gamePosition?.currentPlayer || body.boardState?.currentPlayer || 2,
      placedPieces: body.placedPieces || { 1: 0, 2: 0 }
    }
    
    // Validate game state
    if (!gameState.board || !Array.isArray(gameState.board) || gameState.board.length !== 16) {
      throw new Error('Invalid board state - must be 16-position array')
    }
    
    // Convert to GamePosition format for agents
    const gamePosition: GamePosition = {
      board: gameState.board,
      phase: gameState.phase,
      player1Pieces: gameState.board.filter(cell => cell === 1).length,
      player2Pieces: gameState.board.filter(cell => cell === 2).length,
      possibleMoves: getPossibleMoves(gameState.board, gameState.phase, gameState.currentPlayer),
      moveHistory: [],
      currentPlayer: gameState.currentPlayer as (1 | 2)
    }
    
    console.log(`üéØ Game State: ${gameState.phase} phase, Player ${gameState.currentPlayer}`)
    console.log(`üé≤ Board State: ${gameState.board.map((c, i) => `${i}:${c === 0 ? '¬∑' : c === 1 ? 'X' : 'O'}`).join(' ')}`)
    console.log(`üìä Available moves: ${gamePosition.possibleMoves.length} - ${gamePosition.possibleMoves.join(', ')}`)
    
    // Get decision from ASI Alliance system
    const decision = await getASIAllianceDecision(gamePosition)
    
    // Format response for frontend compatibility  
    const response = {
      move: gameState.phase === 'placement' ? decision.move : decision.move,
      reasoning: decision.reasoning,
      confidence: decision.confidence,
      agent: decision.agent,
      score: decision.score || 0,
      phase: gameState.phase,
      refereeValidated: true,
      asiAlliance: true,
      modular: true
    }
    
    console.log('‚úÖ ASI Alliance Decision:', {
      move: response.move,
      agent: response.agent,
      confidence: response.confidence
    })
    
    return NextResponse.json(response)
    
  } catch (error) {
    console.error('‚ùå Enhanced ASI Alliance Error:', error)
    return NextResponse.json({ 
      error: `ASI Alliance error: ${error instanceof Error ? error.message : 'Unknown error'}`,
      fallback: true
    }, { status: 500 })
  }
}

/**
 * Main ASI Alliance decision system using modular architecture
 */
async function getASIAllianceDecision(gamePosition: GamePosition): Promise<ExtendedAgentDecision> {
  console.log('ü§ñ ASI Alliance: Activating 4-agent consultation system...')
  console.log(`üö® CRITICAL DEBUG: getASIAllianceDecision called for phase: ${gamePosition.phase}`)
  
  // Initialize referee system
  const referee = new QuadraXReferee()
  
  console.log('üèÅ REFEREE: Checking for guaranteed winning moves...')
  console.log(`üéØ Current player: ${gamePosition.currentPlayer}, Phase: ${gamePosition.phase}`)
  console.log(`üé≤ Board for referee: ${gamePosition.board.map((c, i) => `${i}:${c === 0 ? '¬∑' : c === 1 ? 'X' : 'O'}`).join(' ')}`)
  console.log(`üöÄ Possible moves for referee: ${JSON.stringify(gamePosition.possibleMoves.slice(0, 5))}... (${gamePosition.possibleMoves.length} total)`)
  
  // Check for guaranteed winning moves first
  console.log(`üéØ REFEREE DEBUG: Checking for winning moves in ${gamePosition.phase} phase`)
  console.log(`üéØ REFEREE DEBUG: Current player ${gamePosition.currentPlayer} has ${gamePosition.possibleMoves.length} possible moves`)
  
  const winningMove = await referee.findWinningMove(
    gamePosition.board,
    gamePosition.currentPlayer,
    gamePosition.possibleMoves,
    gamePosition.phase
  )
  
  if (winningMove) {
    console.log('üèÜ REFEREE: Guaranteed winning move found!')
    console.log(`üèÜ REFEREE: Winning move details: ${JSON.stringify(winningMove)}`)
    return {
      move: winningMove.move,
      reasoning: `WINNING MOVE: ${winningMove.reasoning}`,
      confidence: 1.0,
      agent: 'QuadraXReferee',
      type: 'referee',
      score: 1000
    }
  } else {
    console.log(`‚ùå REFEREE: No winning move found for player ${gamePosition.currentPlayer}`)
  }
  
  // Check for critical blocks (opponent about to win) using enhanced referee
  console.log('üö® REFEREE: Checking for critical opponent threats...')
  console.log(`üéØ Looking for opponent (Player ${gamePosition.currentPlayer === 1 ? 2 : 1}) winning moves...`)
  
  // Use enhanced referee threat detection (includes future movement threats)
  const threatResponse = await referee.checkThreats(
    gamePosition.board,
    gamePosition.currentPlayer,
    gamePosition.possibleMoves,
    gamePosition.phase
  )
  
  if (threatResponse) {
    console.log('ÔøΩÔ∏è ENHANCED REFEREE: Critical threat detected!')
    console.log(`ÔøΩÔ∏è ENHANCED REFEREE: ${threatResponse.reasoning}`)
    
    return NextResponse.json({
      move: threatResponse.move,
      reasoning: threatResponse.reasoning,
      confidence: 0.98,
      agent: 'QuadraXReferee',
      type: 'threat_block',
      score: 950,
      agentCount: 1,
      refereeValidated: true,
      timestamp: Date.now()
    })
  }
      
      // CRITICAL: Also check movement threats 
      const humanPiecesCount = currentBoard.filter(cell => cell === humanPlayer).length
      const isMovementPhase = gamePosition.phase.toString() === 'movement'
      if (isMovementPhase || humanPiecesCount >= 4) {
        console.log(`üîç REFEREE: Checking human movement threats (phase: ${gamePosition.phase}, human pieces: ${humanPiecesCount})...`)
        const humanPieces = currentBoard.map((cell, idx) => cell === humanPlayer ? idx : null).filter(pos => pos !== null)
        const emptyPositions = currentBoard.map((cell, idx) => cell === 0 ? idx : null).filter(pos => pos !== null)
        
        let movementThreats = 0
        const movementThreatMoves: string[] = []
        
        for (const piecePos of humanPieces) {
          for (const emptyPos of emptyPositions) {
            const testBoard = [...currentBoard]
            testBoard[piecePos] = 0 // Remove piece from current position
            testBoard[emptyPos] = humanPlayer // Place at new position
            
            if (checkWin(testBoard, humanPlayer)) {
              movementThreats++
              movementThreatMoves.push(`${piecePos}‚Üí${emptyPos}`)
              console.log(`üö® MOVEMENT THREAT: Human can win by moving ${piecePos}‚Üí${emptyPos}!`)
            }
          }
        }
        
        if (movementThreats >= 2) {
          console.log(`üö®üö® CRITICAL MOVEMENT MULTI-THREAT: Human has ${movementThreats} winning moves: ${movementThreatMoves.join(', ')}`)
          console.log(`üö®üö® GAME LOST: Cannot block multiple movement threats simultaneously!`)
        } else if (movementThreats === 1) {
          console.log(`üö® SINGLE MOVEMENT THREAT: Human can win with ${movementThreatMoves[0]}`)
          humanThreats += movementThreats
        }
      }    if (humanThreats >= 2) {
      console.log(`üö®üö® CRITICAL: Human already has ${humanThreats} winning options at positions: ${threatPositions.join(', ')} - MULTI-THREAT SITUATION!`)
      console.log(`üö®üö® GAME EFFECTIVELY LOST - AI cannot block all threats simultaneously!`)
      
      // Try to block the most dangerous threat or create counter-threats
      if (threatPositions.length > 0 && gamePosition.possibleMoves.includes(threatPositions[0])) {
        console.log(`üõ°Ô∏è EMERGENCY: Attempting to block first threat at position ${threatPositions[0]}`)
        return {
          move: threatPositions[0],
          reasoning: `EMERGENCY MULTI-THREAT BLOCK: Blocking one of ${humanThreats} opponent winning positions`,
          confidence: 0.99,
          agent: 'QuadraXReferee',
          type: 'referee',
          score: 950
        }
      }
    }

    // PREVENTIVE ANALYSIS: Check if opponent is about to create multi-threats
    console.log('üîç REFEREE: Preventive analysis - checking if opponent can create multi-threats...')
    const availablePlacements = gamePosition.possibleMoves as number[]
    
    for (const opponentMove of availablePlacements) {
      const testBoard = [...currentBoard]
      testBoard[opponentMove] = humanPlayer
      
      // Count how many 1-move wins opponent would have after this placement
      let futureThreats = 0
      for (let pos = 0; pos < 16; pos++) {
        if (testBoard[pos] === 0) {
          const winTestBoard = [...testBoard]
          winTestBoard[pos] = humanPlayer
          if (checkWin(winTestBoard, humanPlayer)) {
            futureThreats++
          }
        }
      }
      
      if (futureThreats >= 2) {
        console.log(`üö® PREVENTION: If opponent places at ${opponentMove}, they'll have ${futureThreats} winning options!`)
        
        // Block this critical position if we can
        if (availablePlacements.includes(opponentMove)) {
          console.log(`üõ°Ô∏è BLOCKING MULTI-THREAT SETUP: Taking position ${opponentMove} to prevent ${futureThreats} threats`)
          return {
            move: opponentMove,
            reasoning: `MULTI-THREAT PREVENTION: Blocking position ${opponentMove} prevents opponent from creating ${futureThreats} winning threats`,
            confidence: 0.98,
            agent: 'QuadraXReferee',
            type: 'referee',
            score: 980
          }
        }
      }
    }
    
    console.log('‚úÖ REFEREE: No imminent multi-threat setups detected')
  }
  
  const criticalBlock = await referee.findBlockingMove(
    gamePosition.board,
    gamePosition.currentPlayer,
    gamePosition.possibleMoves,
    gamePosition.phase
  )
  
  if (criticalBlock) {
    console.log('üõ°Ô∏è REFEREE: Critical block required!')
    console.log(`üö´ Blocking move: ${JSON.stringify(criticalBlock.move)}`)
    console.log(`üö´ Blocking reasoning: ${criticalBlock.reasoning}`)
    return {
      move: criticalBlock.move,
      reasoning: `CRITICAL BLOCK: ${criticalBlock.reasoning}`,
      confidence: 0.95,
      agent: 'QuadraXReferee',
      type: 'referee',
      score: 900,
      agentCount: 1,
      refereeValidated: true,
      timestamp: Date.now()
    } as ExtendedAgentDecision
  } else {
    console.log('‚úÖ REFEREE: No critical opponent threats detected')
  }
  
  // Consult all 4 agents for strategic analysis
  const agentDecisions = await consultAllAgents(gamePosition)
  
  if (agentDecisions.length === 0) {
    throw new Error('All ASI Alliance agents failed to respond')
  }
  
  console.log('üîç Raw agent decisions before scoring:')
  agentDecisions.forEach(decision => {
    console.log(`  ${decision.agent}: move ${decision.move}, confidence ${decision.confidence}`)
  })
  
  // Score and validate all decisions through referee
  const scoredDecisions = await Promise.all(
    agentDecisions.map(async (decision) => {
      const score = await scoreMove(
        gamePosition.board,
        decision.move,
        gamePosition.currentPlayer,
        gamePosition.phase
      )
      
      console.log(`üéØ Scoring ${decision.agent}: move ${decision.move} = ${score} points`)
      
      return {
        ...decision,
        score: score
      }
    })
  )
  
  // Select best decision based on additive scoring (score + confidence bonus)
  // Prioritize move quality over agent confidence
  console.log('üîç All scored decisions:')
  scoredDecisions.forEach(decision => {
    const confidenceBonus = (decision.confidence - 0.5) * 20 // ¬±10 points based on confidence
    const finalScore = (decision.score || 0) + confidenceBonus
    console.log(`  ${decision.agent}: move ${decision.move}, base score ${decision.score}, confidence ${decision.confidence}, bonus ${confidenceBonus.toFixed(1)}, final ${finalScore.toFixed(1)}`)
  })
  
  const bestDecision = scoredDecisions.reduce((best, current) => {
    const bestFinalScore = (best.score || 0) + ((best.confidence - 0.5) * 20)
    const currentFinalScore = (current.score || 0) + ((current.confidence - 0.5) * 20)
    console.log(`üîÄ Comparing ${current.agent} (${currentFinalScore.toFixed(1)}) vs ${best.agent} (${bestFinalScore.toFixed(1)})`)
    return currentFinalScore > bestFinalScore ? current : best
  })
  
  console.log('üèÜ ASI Alliance Final Decision:', {
    agent: bestDecision.agent,
    move: bestDecision.move,
    score: bestDecision.score,
    confidence: bestDecision.confidence
  })
  
  return bestDecision
}

/**
 * Consult all 4 ASI Alliance agents
 */
async function consultAllAgents(gamePosition: GamePosition): Promise<AgentDecision[]> {
  console.log('üë• Consulting all ASI Alliance agents...')
  
  const agents = await ASIAllianceFactory.createAllAgents()
  const opponentProfile: OpponentProfile = {
    playStyle: 'strategic',
    skillLevel: 'advanced',
    preferredPositions: [5, 6, 9, 10],
    gameHistory: [],
    winRate: 0.8
  }
  
  const decisions: AgentDecision[] = []
  
  // Alpha Strategist - Strategic Analysis
  try {
    console.log('üß† Consulting AlphaStrategist...')
    const alphaDecision = await agents.alphaStrategist.selectQuadraXMove(
      gamePosition,
      opponentProfile,
      30000 // 30 second timeout
    )
    decisions.push(alphaDecision)
    console.log(`‚úÖ AlphaStrategist decision: confidence ${alphaDecision.confidence}`)
  } catch (error) {
    console.log('‚ö†Ô∏è AlphaStrategist failed:', error)
  }
  
  // Beta Defender - Defensive Analysis
  try {
    console.log('üõ°Ô∏è Consulting BetaDefender...')
    const betaDecision = await agents.betaDefender.selectQuadraXMove(
      gamePosition,
      opponentProfile,
      30000
    )
    decisions.push(betaDecision)
    console.log(`‚úÖ BetaDefender decision: confidence ${betaDecision.confidence}`)
  } catch (error) {
    console.log('‚ö†Ô∏è BetaDefender failed:', error)
  }
  
  // Gamma Aggressor - Aggressive Analysis
  try {
    console.log('‚öîÔ∏è Consulting GammaAggressor...')
    const gammaDecision = await agents.gammaAggressor.selectQuadraXMove(
      gamePosition,
      opponentProfile,
      30000
    )
    decisions.push(gammaDecision)
    console.log(`‚úÖ GammaAggressor decision: confidence ${gammaDecision.confidence}`)
  } catch (error) {
    console.log('‚ö†Ô∏è GammaAggressor failed:', error)
  }
  
  // Delta Adaptive - Adaptive Analysis
  try {
    console.log('üîÑ Consulting DeltaAdaptive...')
    const deltaDecision = await agents.deltaAdaptive.selectQuadraXMove(
      gamePosition,
      opponentProfile,
      30000
    )
    decisions.push(deltaDecision)
    console.log(`‚úÖ DeltaAdaptive decision: confidence ${deltaDecision.confidence}`)
  } catch (error) {
    console.log('‚ö†Ô∏è DeltaAdaptive failed:', error)
  }
  
  console.log(`üèÅ Agent consultation complete: ${decisions.length}/4 agents responded`)
  return decisions
}

/**
 * Analyze threat level on the board
 */
function analyzeThreatLevel(board: number[], currentPlayer: number): 'low' | 'medium' | 'high' | 'critical' {
  const opponent = currentPlayer === 1 ? 2 : 1
  
  // Check for immediate win threats (opponent needs 1 move to win)
  const winPatterns = [
    // 2x2 squares (primary threat)
    [0,1,4,5], [1,2,5,6], [2,3,6,7], [4,5,8,9], 
    [5,6,9,10], [6,7,10,11], [8,9,12,13], [9,10,13,14], [10,11,14,15],
    // 4-in-a-row (secondary threat)  
    [0,1,2,3], [4,5,6,7], [8,9,10,11], [12,13,14,15],
    [0,4,8,12], [1,5,9,13], [2,6,10,14], [3,7,11,15],
    [0,5,10,15], [3,6,9,12]
  ]
  
  for (const pattern of winPatterns) {
    const opponentPieces = pattern.filter(pos => board[pos] === opponent).length
    const emptySpaces = pattern.filter(pos => board[pos] === 0).length
    
    if (opponentPieces === 3 && emptySpaces === 1) {
      return 'critical' // Opponent wins next move
    }
    if (opponentPieces === 2 && emptySpaces === 2) {
      return 'high' // Opponent has strong setup
    }
  }
  
  // Check our own opportunities
  for (const pattern of winPatterns) {
    const myPieces = pattern.filter(pos => board[pos] === currentPlayer).length
    if (myPieces >= 2) {
      return 'medium' // We have good opportunities
    }
  }
  
  return 'low'
}