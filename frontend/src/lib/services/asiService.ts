// ASI Alliance Service Module with Ollama Fallback
// Handles all ASI:One API communication and response parsing with local Ollama backup

import type { GamePosition, ASIResponse } from '../agents/asi-alliance/types'
import { ollamaService } from './ollamaService'

/**
 * Call ASI Alliance API with Ollama fallback on failure
 */
export async function callASIAllianceWithFallback(
  prompt: string, 
  agentType: 'alpha' | 'beta' | 'gamma' | 'delta' = 'alpha',
  gamePosition?: { board: number[], phase: 'placement' | 'movement', currentPlayer: 1 | 2, availableMoves?: any[] }
): Promise<string> {
  try {
    // Try ASI:One API first
    console.log('üåê Attempting ASI:One API...')
    return await callASIAlliance(prompt)
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error)
    console.log(`‚ùå ASI:One API failed: ${errorMessage}`)
    
    // Check if we have game position for Ollama fallback
    if (gamePosition) {
      console.log('ü¶ô Falling back to Ollama + Llama 3.2...')
      try {
        const ollamaMove = await ollamaService.generateAgentMove(
          gamePosition.board,
          gamePosition.phase,
          gamePosition.currentPlayer,
          agentType,
          gamePosition.availableMoves || []
        )
        
        // Format as ASI-style response
        const formattedResponse = `DECISION: ${gamePosition.phase === 'placement' ? ollamaMove.position : `${ollamaMove.fromPosition}‚Üí${ollamaMove.position}`}
REASONING: ${ollamaMove.reasoning}
CONFIDENCE: ${ollamaMove.confidence}
AGENT: ${agentType.toUpperCase()} (Ollama/Llama3.2)

This move analysis was generated by local Ollama + Llama 3.2 as fallback for ASI:One API.`

        console.log('‚úÖ Ollama fallback successful!')
        return formattedResponse
      } catch (ollamaError) {
        console.error('‚ùå Ollama fallback also failed:', ollamaError)
        throw new Error(`Both ASI:One API and Ollama fallback failed. ASI: ${errorMessage}, Ollama: ${ollamaError}`)
      }
    } else {
      // No game position provided for fallback
      throw error
    }
  }
}

/**
 * Call ASI Alliance API with authentication and error handling
 */
export async function callASIAlliance(prompt: string): Promise<string> {
  const apiKey = process.env.NEXT_PUBLIC_ASI_API_KEY || process.env.ASI_API_KEY
  
  console.log('üîç DEBUG: API Key check:', {
    hasApiKey: !!apiKey,
    keyLength: apiKey?.length || 0,
    keyPrefix: apiKey?.substring(0, 8) || 'none'
  })
  
  // Require valid ASI API key - no demo keys allowed
  if (!apiKey || apiKey.length < 20 || !apiKey.startsWith('sk_')) {
    throw new Error(`
üîë ASI:One API Key Required:
- Missing or invalid API key detected
- Get your key from: https://asi1.ai/dashboard/api-keys  
- Set NEXT_PUBLIC_ASI_API_KEY in your .env.local file
- Current key status: ${!apiKey ? 'Missing' : 'Invalid format'}`)
  }

  try {
    console.log('ü§ñ Calling ASI Alliance API...')
    console.log('üìù Prompt preview:', prompt.slice(0, 150) + '...')
    
    const response = await fetch('https://api.asi1.ai/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: 'asi1-mini',
        messages: [
          {
            role: 'system',
            content: 'You are a QuadraX gaming AI expert. Always provide specific move numbers or movement instructions. Be decisive and strategic.'
          },
          {
            role: 'user', 
            content: prompt
          }
        ],
        max_tokens: 500,
        temperature: 0.8
      })
    })

    if (!response.ok) {
      const errorText = await response.text()
      
      // Check for rate limiting
      if (response.status === 429) {
        throw new Error(`ASI:One API rate limit exceeded. Please wait before making more requests.
Status: ${response.status}
Response: ${errorText}

üí° Solutions:
- Wait 60 seconds before retrying
- Check your API plan limits at https://asi1.ai/dashboard/usage
- Consider upgrading your plan for higher limits`)
      }
      
      // Check for authentication issues
      if (response.status === 401) {
        throw new Error(`ASI:One API authentication failed: ${response.status} - ${errorText}
üîë API Key Issue Detected:
- Make sure you have a valid API key from https://asi1.ai/dashboard/api-keys
- Check that your API key is properly set in environment variables
- Verify your ASI:One account has API access enabled`)
      }
      
      throw new Error(`ASI:One API authentication failed: ${response.status} - ${errorText}
üîë API Key Issue Detected:
- Make sure you have a valid API key from https://asi1.ai/dashboard/api-keys
- Check that your API key is properly set in environment variables
- Verify your ASI:One account has API access enabled`)
    }
    
    const data = await response.json()
    console.log('üîç DEBUG: ASI API Response Data:', JSON.stringify(data, null, 2))
    
    const aiResponse = data.choices?.[0]?.message?.content
    if (!aiResponse) {
      throw new Error('ASI:One API returned empty response')
    }
    
    console.log('‚úÖ ASI API Success Response:', aiResponse)
    return aiResponse
  } catch (error) {
    console.error('‚ùå ASI API Call Failed:', error)
    throw error
  }
}

/**
 * Parse ASI Alliance response into structured format
 */
export function parseASIResponse(response: string, gamePosition: any): ASIResponse {
  console.log('üîç Parsing ASI Alliance response:', response)
  
  // Extract move from response
  let move: number | { from: number; to: number } = gamePosition.possibleMoves?.[0] // First valid option
  let confidence = 0.8
  let reasoning = response.slice(0, 200)

  // Parse placement moves (single numbers)
  if (gamePosition.phase === 'placement') {
    const moveMatches = response.match(/(?:move|position|place)[\s:]*(\d+)/i)
    if (moveMatches) {
      const parsedMove = parseInt(moveMatches[1])
      if (!isNaN(parsedMove) && parsedMove >= 0 && parsedMove <= 15) {
        move = parsedMove
      }
    }
  }

  // Parse movement moves (from‚Üíto format)
  if (gamePosition.phase === 'movement') {
    const movementMatches = response.match(/(\d+)\s*(?:‚Üí|->|to)\s*(\d+)/i)
    if (movementMatches) {
      const from = parseInt(movementMatches[1])
      const to = parseInt(movementMatches[2])
      if (!isNaN(from) && !isNaN(to) && from >= 0 && from <= 15 && to >= 0 && to <= 15) {
        move = { from, to }
      }
    }
  }

  // Extract confidence level
  const confidenceMatch = response.match(/confidence[:\s]*([0-9.]+)/i)
  if (confidenceMatch) {
    confidence = Math.min(1.0, Math.max(0.0, parseFloat(confidenceMatch[1])))
  }

  // Extract reasoning
  const reasoningMatch = response.match(/reasoning[:\s]*(.+?)(?:\n|$)/i)
  if (reasoningMatch) {
    reasoning = reasoningMatch[1].trim()
  }

  return {
    move: move,
    confidence: confidence,
    reasoning: reasoning,
    tacticalAnalysis: `ASI Alliance ${gamePosition.phase} analysis`,
    phaseStrategy: gamePosition.phase
  }
}

/**
 * Create agent-specific prompts for different strategies
 */
export function createAgentPrompt(
  agentType: string,
  gamePosition: GamePosition,
  opponentProfile?: any
): string {
  const { board, phase, possibleMoves } = gamePosition

  const agentFocus = {
    strategic: 'CENTER CONTROL & LONG-TERM POSITIONING',
    defensive: 'THREAT DETECTION & BLOCKING PATTERNS', 
    aggressive: 'IMMEDIATE WIN CREATION & PRESSURE',
    adaptive: 'PATTERN RECOGNITION & COUNTER-STRATEGY'
  }[agentType] || 'STRATEGIC ANALYSIS'

  const movesStr = possibleMoves.map((m: any) => 
    typeof m === 'object' ? `${m.from}‚Üí${m.to}` : m
  ).join(', ')

  return `ü§ñ ${agentType.toUpperCase()} AGENT - QuadraX ${phase.toUpperCase()} Analysis

**AGENT FOCUS**: ${agentFocus}

**BOARD STATE**: [${board.join(',')}]
**PHASE**: ${phase}
**AVAILABLE MOVES**: ${movesStr}

**DECISION REQUIRED**:
Analyze the position and select the optimal move.

**RESPONSE FORMAT**:
Move: [SELECT MOVE]
Confidence: [0.0-1.0] 
Reasoning: [BRIEF ANALYSIS]

Make your decision now!`
}

export default { callASIAlliance, parseASIResponse, createAgentPrompt }