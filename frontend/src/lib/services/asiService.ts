// ASI Alliance Service Module with Ollama Fallback
// Handles all ASI:One API communication and response parsing with local Ollama backup

import type { GamePosition, ASIResponse } from '../agents/asi-alliance/types'
import { ollamaService } from './ollamaService'

/**
 * Call ASI:One API with proper agentic reasoning configuration
 */
async function callASIAllianceAgentic(prompt: string, agentType: string): Promise<string> {
  const apiKey = process.env.NEXT_PUBLIC_ASI_API_KEY || process.env.ASI_API_KEY
  
  if (!apiKey || apiKey.length < 20 || !apiKey.startsWith('sk_')) {
    throw new Error('ASI:One API Key Required')
  }

  console.log(`ü§ñ ASI:One Agentic Call - ${agentType.toUpperCase()} Agent`)
  
  const response = await fetch('https://api.asi1.ai/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      model: 'asi1-mini',
      messages: [
        {
          role: 'system',
          content: `You are an autonomous QuadraX agent with advanced agentic reasoning. Use multi-step analysis, contextual memory, and goal-driven decision making. Think autonomously and provide precise JSON responses.`
        },
        {
          role: 'user', 
          content: prompt
        }
      ],
      max_tokens: 800,
      temperature: 0.7,
      // Enable agentic features
      stream: false
    })
  })

  if (!response.ok) {
    const errorText = await response.text()
    throw new Error(`ASI:One API Error: ${response.status} - ${errorText}`)
  }

  const data = await response.json()
  console.log('üîç DEBUG: ASI API Response Data:', JSON.stringify(data, null, 2))
  
  if (data.choices && data.choices.length > 0) {
    const content = data.choices[0].message.content
    console.log('‚úÖ ASI API Success Response:', content)
    return content
  } else {
    throw new Error('Invalid ASI API response structure')
  }
}

/**
 * Call ASI Alliance API with Ollama fallback on failure
 */
export async function callASIAllianceWithFallback(
  prompt: string, 
  agentType: 'alpha' | 'beta' | 'gamma' | 'delta' = 'alpha',
  gamePosition?: { board: number[], phase: 'placement' | 'movement', currentPlayer: 1 | 2, availableMoves?: any[] }
): Promise<string> {
  try {
    // Try ASI:One API with agentic reasoning
    console.log('ü§ñ Calling ASI:One with agentic reasoning...')
    return await callASIAllianceAgentic(prompt, agentType)
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error)
    console.log(`‚ùå ASI:One API failed: ${errorMessage}`)
    
    // Check if we have game position for Ollama fallback
    if (gamePosition) {
      console.log('ü¶ô Falling back to Ollama + Llama 3.2...')
      try {
        const ollamaMove = await ollamaService.generateAgentMove(
          gamePosition.board,
          gamePosition.phase,
          gamePosition.currentPlayer,
          agentType,
          gamePosition.availableMoves || []
        )
        
        // Format as ASI-style response
        const formattedResponse = `DECISION: ${gamePosition.phase === 'placement' ? ollamaMove.position : `${ollamaMove.fromPosition}‚Üí${ollamaMove.position}`}
REASONING: ${ollamaMove.reasoning}
CONFIDENCE: ${ollamaMove.confidence}
AGENT: ${agentType.toUpperCase()} (Ollama/Llama3.2)

This move analysis was generated by local Ollama + Llama 3.2 as fallback for ASI:One API.`

        console.log('‚úÖ Ollama fallback successful!')
        return formattedResponse
      } catch (ollamaError) {
        console.error('‚ùå Ollama fallback also failed:', ollamaError)
        throw new Error(`Both ASI:One API and Ollama fallback failed. ASI: ${errorMessage}, Ollama: ${ollamaError}`)
      }
    } else {
      // No game position provided for fallback
      throw error
    }
  }
}

/**
 * Call ASI Alliance API with authentication and error handling
 */
export async function callASIAlliance(prompt: string): Promise<string> {
  const apiKey = process.env.NEXT_PUBLIC_ASI_API_KEY || process.env.ASI_API_KEY
  
  console.log('üîç DEBUG: API Key check:', {
    hasApiKey: !!apiKey,
    keyLength: apiKey?.length || 0,
    keyPrefix: apiKey?.substring(0, 8) || 'none'
  })
  
  // Require valid ASI API key - no demo keys allowed
  if (!apiKey || apiKey.length < 20 || !apiKey.startsWith('sk_')) {
    throw new Error(`
üîë ASI:One API Key Required:
- Missing or invalid API key detected
- Get your key from: https://asi1.ai/dashboard/api-keys  
- Set NEXT_PUBLIC_ASI_API_KEY in your .env.local file
- Current key status: ${!apiKey ? 'Missing' : 'Invalid format'}`)
  }

  try {
    console.log('ü§ñ Calling ASI Alliance API...')
    console.log('üìù Prompt preview:', prompt.slice(0, 150) + '...')
    
    const response = await fetch('https://api.asi1.ai/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: 'asi1-mini',
        messages: [
          {
            role: 'system',
            content: 'You are a QuadraX gaming AI expert. Always provide specific move numbers or movement instructions. Be decisive and strategic.'
          },
          {
            role: 'user', 
            content: prompt
          }
        ],
        max_tokens: 500,
        temperature: 0.8
      })
    })

    if (!response.ok) {
      const errorText = await response.text()
      
      // Check for rate limiting
      if (response.status === 429) {
        throw new Error(`ASI:One API rate limit exceeded. Please wait before making more requests.
Status: ${response.status}
Response: ${errorText}

üí° Solutions:
- Wait 60 seconds before retrying
- Check your API plan limits at https://asi1.ai/dashboard/usage
- Consider upgrading your plan for higher limits`)
      }
      
      // Check for authentication issues
      if (response.status === 401) {
        throw new Error(`ASI:One API authentication failed: ${response.status} - ${errorText}
üîë API Key Issue Detected:
- Make sure you have a valid API key from https://asi1.ai/dashboard/api-keys
- Check that your API key is properly set in environment variables
- Verify your ASI:One account has API access enabled`)
      }
      
      throw new Error(`ASI:One API authentication failed: ${response.status} - ${errorText}
üîë API Key Issue Detected:
- Make sure you have a valid API key from https://asi1.ai/dashboard/api-keys
- Check that your API key is properly set in environment variables
- Verify your ASI:One account has API access enabled`)
    }
    
    const data = await response.json()
    console.log('üîç DEBUG: ASI API Response Data:', JSON.stringify(data, null, 2))
    
    const aiResponse = data.choices?.[0]?.message?.content
    if (!aiResponse) {
      throw new Error('ASI:One API returned empty response')
    }
    
    console.log('‚úÖ ASI API Success Response:', aiResponse)
    return aiResponse
  } catch (error) {
    console.error('‚ùå ASI API Call Failed:', error)
    throw error
  }
}

/**
 * Parse ASI Alliance response into structured format
 */
export function parseASIResponse(response: string, gamePosition: any): ASIResponse {
  console.log('üîç Parsing ASI Alliance response:', response)
  
  // Default values
  let move: number | { from: number; to: number } = gamePosition.possibleMoves?.[0] // First valid option
  let confidence = 0.8
  let reasoning = response.slice(0, 200)
  let tacticalAnalysis = undefined

  try {
    // Try to parse JSON response first
    const jsonMatch = response.match(/\{[\s\S]*\}/)
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0])
      
      // Validate and extract move
      if (parsed.move !== undefined) {
        if (gamePosition.phase === 'placement') {
          const parsedMove = typeof parsed.move === 'number' ? parsed.move : parseInt(parsed.move)
          // CRITICAL: Validate move is available
          if (!isNaN(parsedMove) && gamePosition.possibleMoves?.includes(parsedMove)) {
            move = parsedMove
            console.log(`‚úÖ Valid move selected: ${parsedMove}`)
          } else {
            console.warn(`‚ö†Ô∏è Invalid move ${parsedMove}, available: [${gamePosition.possibleMoves?.join(', ')}]`)
            console.log(`üé≤ Board: ${gamePosition.board.map((c: number, i: number) => `${i}:${c === 0 ? '¬∑' : c === 1 ? 'X' : 'O'}`).join(' ')}`)
            // Find best alternative from available moves (prefer center positions)
            const centerMoves = [5, 6, 9, 10].filter(m => gamePosition.possibleMoves?.includes(m))
            const selectedFallback = centerMoves[0] || gamePosition.possibleMoves?.[0]
            console.log(`üîÑ Using fallback move: ${selectedFallback}`)
            move = selectedFallback
            reasoning = `Fallback selection: ${selectedFallback} (AI suggested ${parsedMove} but position occupied)`
          }
        } else if (gamePosition.phase === 'movement') {
          if (typeof parsed.move === 'object' && parsed.move.from !== undefined && parsed.move.to !== undefined) {
            const from = parseInt(parsed.move.from)
            const to = parseInt(parsed.move.to)
            // Validate movement is available
            const validMove = gamePosition.possibleMoves?.find((m: any) => 
              m.from === from && m.to === to
            )
            if (validMove) {
              move = { from, to }
            } else {
              console.warn(`‚ö†Ô∏è Invalid movement ${from}‚Üí${to}, using first available`)
              move = gamePosition.possibleMoves?.[0]
            }
          }
        }
      }
      
      // Extract other fields
      if (parsed.confidence !== undefined) {
        confidence = Math.min(1.0, Math.max(0.0, parseFloat(parsed.confidence)))
      }
      
      if (parsed.reasoning) {
        reasoning = parsed.reasoning
      }
      
      if (parsed.tacticalAnalysis) {
        tacticalAnalysis = parsed.tacticalAnalysis
      }
      
    } else {
      // Fallback to regex parsing for non-JSON responses
      console.log('üìÑ Non-JSON response, using regex parsing')
      
      // Parse placement moves (single numbers)
      if (gamePosition.phase === 'placement') {
        const moveMatches = response.match(/(?:move|position|place)[\s:]*(\d+)/i)
        if (moveMatches) {
          const parsedMove = parseInt(moveMatches[1])
          if (!isNaN(parsedMove) && gamePosition.possibleMoves?.includes(parsedMove)) {
            move = parsedMove
          }
        }
      }

      // Parse movement moves (from‚Üíto format)
      if (gamePosition.phase === 'movement') {
        const movementMatches = response.match(/(\d+)\s*(?:‚Üí|->|to)\s*(\d+)/i)
        if (movementMatches) {
          const from = parseInt(movementMatches[1])
          const to = parseInt(movementMatches[2])
          const validMove = gamePosition.possibleMoves?.find((m: any) => 
            m.from === from && m.to === to
          )
          if (validMove) {
            move = { from, to }
          }
        }
      }

      // Extract confidence level
      const confidenceMatch = response.match(/confidence[:\s]*([0-9.]+)/i)
      if (confidenceMatch) {
        confidence = Math.min(1.0, Math.max(0.0, parseFloat(confidenceMatch[1])))
      }

      // Extract reasoning
      const reasoningMatch = response.match(/reasoning[:\s]*(.+?)(?:\n|$)/i)
      if (reasoningMatch) {
        reasoning = reasoningMatch[1].trim()
      }
    }
  } catch (parseError) {
    console.error('‚ùå Response parsing error:', parseError)
    // Use fallback move
    console.log('üîÑ Using fallback move selection')
  }

  return {
    move: move,
    confidence: confidence,
    reasoning: reasoning,
    tacticalAnalysis: `ASI Alliance ${gamePosition.phase} analysis`,
    phaseStrategy: gamePosition.phase
  }
}

/**
 * Create agent-specific prompts for different strategies
 */
export function createAgentPrompt(
  agentType: string,
  gamePosition: GamePosition,
  opponentProfile?: any
): string {
  const { board, phase, possibleMoves } = gamePosition

  const agentFocus = {
    strategic: 'CENTER CONTROL & LONG-TERM POSITIONING',
    defensive: 'THREAT DETECTION & BLOCKING PATTERNS', 
    aggressive: 'IMMEDIATE WIN CREATION & PRESSURE',
    adaptive: 'PATTERN RECOGNITION & COUNTER-STRATEGY'
  }[agentType] || 'STRATEGIC ANALYSIS'

  const movesStr = possibleMoves.map((m: any) => 
    typeof m === 'object' ? `${m.from}‚Üí${m.to}` : m
  ).join(', ')

  return `ü§ñ ${agentType.toUpperCase()} AGENT - QuadraX ${phase.toUpperCase()} Analysis

**AGENT FOCUS**: ${agentFocus}

**BOARD STATE**: [${board.join(',')}]
**PHASE**: ${phase}
**AVAILABLE MOVES**: ${movesStr}

**DECISION REQUIRED**:
Analyze the position and select the optimal move.

**RESPONSE FORMAT**:
Move: [SELECT MOVE]
Confidence: [0.0-1.0] 
Reasoning: [BRIEF ANALYSIS]

Make your decision now!`
}

export default { callASIAlliance, parseASIResponse, createAgentPrompt }